!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
MODULE triangles
  IMPLICIT NONE

CONTAINS
!  Differentiation of point_tri in forward (tangent) mode:
!   variations   of useful results: dsquared
!   with respect to varying inputs: p a b c
!   RW status of diff variables: dsquared:out p:in a:in b:in c:in
  SUBROUTINE POINT_TRI_D(a, ad, b, bd, c, cd, p, pd, dsquared, dsquaredd&
& )
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) :: a, b, c, p
    REAL, DIMENSION(3), INTENT(IN) :: ad, bd, cd, pd
    REAL, INTENT(OUT) :: dsquared
    REAL, INTENT(OUT) :: dsquaredd
    REAL, DIMENSION(3) :: ab, ac, ap, bp, cp, closepoint, diff, &
&   dummydiff
    REAL, DIMENSION(3) :: abd, acd, apd, bpd, cpd, closepointd, diffd, &
&   dummydiffd
    REAL :: d1, d2, d3, d4, d5, d6
    REAL :: d1d, d2d, d3d, d4d, d5d, d6d
    REAL :: v, vc, vb, va, w, denom
    REAL :: vd, vcd, vbd, vad, wd, denomd
    abd = bd - ad
    ab = b - a
    acd = cd - ad
    ac = c - a
    apd = pd - ad
    ap = p - a
    CALL DOT_PROD_D(d1, d1d, ab, abd, ap, apd)
    CALL DOT_PROD_D(d2, d2d, ac, acd, ap, apd)
    IF (d1 .LE. 0.0 .AND. d2 .LE. 0.0) THEN
! barycentric 1, 0, 0
      closepointd = ad
      closepoint = a
      diffd = closepointd - pd
      diff = closepoint - p
      dummydiffd = diffd
      dummydiff = diff
      CALL DOT_PROD_D(dsquared, dsquaredd, diff, diffd, dummydiff, &
&               dummydiffd)
      RETURN
    ELSE
! check if P in vertex region outside B
      bpd = pd - bd
      bp = p - b
      CALL DOT_PROD_D(d3, d3d, ab, abd, bp, bpd)
      CALL DOT_PROD_D(d4, d4d, ac, acd, bp, bpd)
      IF (d3 .GE. 0.0 .AND. d4 .LE. d3) THEN
! barycentric 0, 1, 0
        closepointd = bd
        closepoint = b
        diffd = closepointd - pd
        diff = closepoint - p
        dummydiffd = diffd
        dummydiff = diff
        CALL DOT_PROD_D(dsquared, dsquaredd, diff, diffd, dummydiff, &
&                 dummydiffd)
        RETURN
      ELSE
! check if P in edge region of AB, if so return projection of P onto AB
        vcd = d1d*d4 + d1*d4d - d3d*d2 - d3*d2d
        vc = d1*d4 - d3*d2
        IF (vc .LE. 0.0 .AND. d1 .GE. 0.0 .AND. d3 .LE. 0.0) THEN
          vd = (d1d*(d1-d3)-d1*(d1d-d3d))/(d1-d3)**2
          v = d1/(d1-d3)
! barycentric coordinates (1-v,v,0)
          closepointd = ad + vd*ab + v*abd
          closepoint = a + v*ab
          diffd = closepointd - pd
          diff = closepoint - p
          dummydiffd = diffd
          dummydiff = diff
          CALL DOT_PROD_D(dsquared, dsquaredd, diff, diffd, dummydiff, &
&                   dummydiffd)
          RETURN
        ELSE
! Check if P in vertex region C
          cpd = pd - cd
          cp = p - c
          CALL DOT_PROD_D(d5, d5d, ab, abd, cp, cpd)
          CALL DOT_PROD_D(d6, d6d, ac, acd, cp, cpd)
          IF (d6 .GE. 0.0 .AND. d5 .LE. d6) THEN
! barycentric coordinates (0,0,1)
            closepointd = cd
            closepoint = c
            diffd = closepointd - pd
            diff = closepoint - p
            dummydiffd = diffd
            dummydiff = diff
            CALL DOT_PROD_D(dsquared, dsquaredd, diff, diffd, dummydiff&
&                     , dummydiffd)
            RETURN
          ELSE
! check if P in edge region of AC, if so, return proj(P,AC)
            vbd = d5d*d2 + d5*d2d - d1d*d6 - d1*d6d
            vb = d5*d2 - d1*d6
            IF (vb .LE. 0.0 .AND. d2 .GE. 0.0 .AND. d6 .LE. 0.0) THEN
              wd = (d2d*(d2-d6)-d2*(d2d-d6d))/(d2-d6)**2
              w = d2/(d2-d6)
! barycentric (1-w, 0, w)
              closepointd = ad + wd*ac + w*acd
              closepoint = a + w*ac
              diffd = closepointd - pd
              diff = closepoint - p
              dummydiffd = diffd
              dummydiff = diff
              CALL DOT_PROD_D(dsquared, dsquaredd, diff, diffd, &
&                       dummydiff, dummydiffd)
              RETURN
            ELSE
! Check if P in edge region of BC, if so, return proj(P,BC)
              vad = d3d*d6 + d3*d6d - d5d*d4 - d5*d4d
              va = d3*d6 - d5*d4
              IF (va .LE. 0.0 .AND. d4 - d3 .GE. 0.0 .AND. d5 - d6 .GE. &
&                 0.0) THEN
                wd = ((d4d-d3d)*(d4-d3+(d5-d6))-(d4-d3)*(d4d-d3d+d5d-d6d&
&                 ))/(d4-d3+(d5-d6))**2
                w = (d4-d3)/(d4-d3+(d5-d6))
! barycentric (0, 1-w, w)
                closepointd = bd + wd*(c-b) + w*(cd-bd)
                closepoint = b + w*(c-b)
                diffd = closepointd - pd
                diff = closepoint - p
                dummydiffd = diffd
                dummydiff = diff
                CALL DOT_PROD_D(dsquared, dsquaredd, diff, diffd, &
&                         dummydiff, dummydiffd)
                RETURN
              ELSE
! P inside face region. Compute Q through barycentric (u, v, w)
                denomd = -((vad+vbd+vcd)/(va+vb+vc)**2)
                denom = 1.0/(va+vb+vc)
                vd = vbd*denom + vb*denomd
                v = vb*denom
                wd = vcd*denom + vc*denomd
                w = vc*denom
                closepointd = ad + abd*v + ab*vd + acd*w + ac*wd
                closepoint = a + ab*v + ac*w
                diffd = closepointd - pd
                diff = closepoint - p
                dummydiffd = diffd
                dummydiff = diff
                CALL DOT_PROD_D(dsquared, dsquaredd, diff, diffd, &
&                         dummydiff, dummydiffd)
                RETURN
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE POINT_TRI_D
!  Differentiation of point_tri in reverse (adjoint) mode:
!   gradient     of useful results: dsquared p a b c
!   with respect to varying inputs: dsquared p a b c
!   RW status of diff variables: dsquared:in-zero p:incr a:incr
!                b:incr c:incr
  SUBROUTINE POINT_TRI_B(a, ab0, b, bb, c, cb, p, pb, dsquared, &
&   dsquaredb)
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) :: a, b, c, p
    REAL, DIMENSION(3), INTENT(OUT) :: ab0, bb, cb, pb
    REAL, INTENT(OUT) :: dsquared
    REAL, INTENT(IN) :: dsquaredb
    REAL, DIMENSION(3) :: ab, ac, ap, bp, cp, closepoint, diff, &
&   dummydiff
    REAL, DIMENSION(3) :: abb, acb, apb, bpb, cpb, closepointb, diffb, &
&   dummydiffb
    REAL :: d1, d2, d3, d4, d5, d6
    REAL :: d1b, d2b, d3b, d4b, d5b, d6b
    REAL :: v, vc, vb, va, w, denom
    REAL :: vb0, vcb, vbb, vab, wb, denomb
    REAL :: tempb5
    REAL :: tempb4
    REAL :: tempb3
    REAL :: tempb2
    REAL :: tempb1
    REAL :: tempb0
    REAL :: tempb
    ab = b - a
    ac = c - a
    ap = p - a
    CALL DOT_PROD(d1, ab, ap)
    CALL DOT_PROD(d2, ac, ap)
    IF (d1 .LE. 0.0 .AND. d2 .LE. 0.0) THEN
! barycentric 1, 0, 0
      closepoint = a
      diff = closepoint - p
      dummydiff = diff
      diffb = 0.0
      dummydiffb = 0.0
      CALL DOT_PROD_B(dsquared, dsquaredb, diff, diffb, dummydiff, &
&               dummydiffb)
      diffb = diffb + dummydiffb
      closepointb = 0.0
      closepointb = diffb
      pb = pb - diffb
      ab0 = ab0 + closepointb
      abb = 0.0
      acb = 0.0
      d1b = 0.0
      d2b = 0.0
    ELSE
! check if P in vertex region outside B
      bp = p - b
      CALL DOT_PROD(d3, ab, bp)
      CALL DOT_PROD(d4, ac, bp)
      IF (d3 .GE. 0.0 .AND. d4 .LE. d3) THEN
! barycentric 0, 1, 0
        closepoint = b
        diff = closepoint - p
        dummydiff = diff
        diffb = 0.0
        dummydiffb = 0.0
        CALL DOT_PROD_B(dsquared, dsquaredb, diff, diffb, dummydiff, &
&                 dummydiffb)
        diffb = diffb + dummydiffb
        closepointb = 0.0
        closepointb = diffb
        pb = pb - diffb
        bb = bb + closepointb
        abb = 0.0
        acb = 0.0
        d1b = 0.0
        d2b = 0.0
        d3b = 0.0
        d4b = 0.0
      ELSE
! check if P in edge region of AB, if so return projection of P onto AB
        vc = d1*d4 - d3*d2
        IF (vc .LE. 0.0 .AND. d1 .GE. 0.0 .AND. d3 .LE. 0.0) THEN
          v = d1/(d1-d3)
! barycentric coordinates (1-v,v,0)
          closepoint = a + v*ab
          diff = closepoint - p
          dummydiff = diff
          diffb = 0.0
          dummydiffb = 0.0
          CALL DOT_PROD_B(dsquared, dsquaredb, diff, diffb, dummydiff, &
&                   dummydiffb)
          diffb = diffb + dummydiffb
          closepointb = 0.0
          closepointb = diffb
          pb = pb - diffb
          abb = 0.0
          ab0 = ab0 + closepointb
          vb0 = SUM(ab*closepointb)
          abb = v*closepointb
          tempb = vb0/(d1-d3)
          tempb0 = -(d1*tempb/(d1-d3))
          d1b = tempb0 + tempb
          d3b = -tempb0
          acb = 0.0
          d2b = 0.0
          d4b = 0.0
          vcb = 0.0
        ELSE
! Check if P in vertex region C
          cp = p - c
          CALL DOT_PROD(d5, ab, cp)
          CALL DOT_PROD(d6, ac, cp)
          IF (d6 .GE. 0.0 .AND. d5 .LE. d6) THEN
! barycentric coordinates (0,0,1)
            closepoint = c
            diff = closepoint - p
            dummydiff = diff
            diffb = 0.0
            dummydiffb = 0.0
            CALL DOT_PROD_B(dsquared, dsquaredb, diff, diffb, dummydiff&
&                     , dummydiffb)
            diffb = diffb + dummydiffb
            closepointb = 0.0
            closepointb = diffb
            pb = pb - diffb
            cb = cb + closepointb
            abb = 0.0
            acb = 0.0
            d1b = 0.0
            d2b = 0.0
            d3b = 0.0
            d4b = 0.0
            d5b = 0.0
            d6b = 0.0
            vcb = 0.0
          ELSE
! check if P in edge region of AC, if so, return proj(P,AC)
            vb = d5*d2 - d1*d6
            IF (vb .LE. 0.0 .AND. d2 .GE. 0.0 .AND. d6 .LE. 0.0) THEN
              w = d2/(d2-d6)
! barycentric (1-w, 0, w)
              closepoint = a + w*ac
              diff = closepoint - p
              dummydiff = diff
              diffb = 0.0
              dummydiffb = 0.0
              CALL DOT_PROD_B(dsquared, dsquaredb, diff, diffb, &
&                       dummydiff, dummydiffb)
              diffb = diffb + dummydiffb
              closepointb = 0.0
              closepointb = diffb
              pb = pb - diffb
              acb = 0.0
              ab0 = ab0 + closepointb
              wb = SUM(ac*closepointb)
              acb = w*closepointb
              tempb1 = wb/(d2-d6)
              tempb2 = -(d2*tempb1/(d2-d6))
              d2b = tempb2 + tempb1
              d6b = -tempb2
              abb = 0.0
              d3b = 0.0
              d4b = 0.0
              d5b = 0.0
              vbb = 0.0
              vcb = 0.0
            ELSE
! Check if P in edge region of BC, if so, return proj(P,BC)
              va = d3*d6 - d5*d4
              IF (va .LE. 0.0 .AND. d4 - d3 .GE. 0.0 .AND. d5 - d6 .GE. &
&                 0.0) THEN
                w = (d4-d3)/(d4-d3+(d5-d6))
! barycentric (0, 1-w, w)
                closepoint = b + w*(c-b)
                diff = closepoint - p
                dummydiff = diff
                diffb = 0.0
                dummydiffb = 0.0
                CALL DOT_PROD_B(dsquared, dsquaredb, diff, diffb, &
&                         dummydiff, dummydiffb)
                diffb = diffb + dummydiffb
                closepointb = 0.0
                closepointb = diffb
                pb = pb - diffb
                bb = bb + closepointb - w*closepointb
                wb = SUM((c-b)*closepointb)
                cb = cb + w*closepointb
                tempb3 = wb/(d4-d3+d5-d6)
                tempb4 = -((d4-d3)*tempb3/(d4-d3+d5-d6))
                d4b = tempb4 + tempb3
                d3b = -tempb4 - tempb3
                d5b = tempb4
                d6b = -tempb4
                abb = 0.0
                acb = 0.0
                vab = 0.0
                vbb = 0.0
                vcb = 0.0
              ELSE
! P inside face region. Compute Q through barycentric (u, v, w)
                denom = 1.0/(va+vb+vc)
                v = vb*denom
                w = vc*denom
                closepoint = a + ab*v + ac*w
                diff = closepoint - p
                dummydiff = diff
                diffb = 0.0
                dummydiffb = 0.0
                CALL DOT_PROD_B(dsquared, dsquaredb, diff, diffb, &
&                         dummydiff, dummydiffb)
                diffb = diffb + dummydiffb
                closepointb = 0.0
                closepointb = diffb
                pb = pb - diffb
                abb = 0.0
                acb = 0.0
                ab0 = ab0 + closepointb
                abb = v*closepointb
                vb0 = SUM(ab*closepointb)
                acb = w*closepointb
                wb = SUM(ac*closepointb)
                denomb = vb*vb0 + vc*wb
                tempb5 = -(denomb/(va+vb+vc)**2)
                vcb = tempb5 + denom*wb
                vbb = tempb5 + denom*vb0
                vab = tempb5
                d3b = 0.0
                d4b = 0.0
                d5b = 0.0
                d6b = 0.0
              END IF
              d3b = d3b + d6*vab
              d6b = d6b + d3*vab
              d5b = d5b - d4*vab
              d4b = d4b - d5*vab
              d2b = 0.0
            END IF
            d5b = d5b + d2*vbb
            d2b = d2b + d5*vbb
            d1b = -(d6*vbb)
            d6b = d6b - d1*vbb
          END IF
          cpb = 0.0
          CALL DOT_PROD_B(d6, d6b, ac, acb, cp, cpb)
          CALL DOT_PROD_B(d5, d5b, ab, abb, cp, cpb)
          pb = pb + cpb
          cb = cb - cpb
        END IF
        d1b = d1b + d4*vcb
        d4b = d4b + d1*vcb
        d3b = d3b - d2*vcb
        d2b = d2b - d3*vcb
      END IF
      bpb = 0.0
      CALL DOT_PROD_B(d4, d4b, ac, acb, bp, bpb)
      CALL DOT_PROD_B(d3, d3b, ab, abb, bp, bpb)
      pb = pb + bpb
      bb = bb - bpb
    END IF
    apb = 0.0
    CALL DOT_PROD_B(d2, d2b, ac, acb, ap, apb)
    CALL DOT_PROD_B(d1, d1b, ab, abb, ap, apb)
    pb = pb + apb
    ab0 = ab0 - acb - abb - apb
    cb = cb + acb
    bb = bb + abb
    !dsquaredb = 0.0
  END SUBROUTINE POINT_TRI_B
!  Differentiation of dot_prod in forward (tangent) mode:
!   variations   of useful results: d
!   with respect to varying inputs: v w
  SUBROUTINE DOT_PROD_D(d, dd, v, vd, w, wd)
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) :: v, w
    REAL, DIMENSION(3), INTENT(IN) :: vd, wd
    REAL, INTENT(OUT) :: d
    REAL, INTENT(OUT) :: dd
    dd = vd(1)*w(1) + v(1)*wd(1) + vd(2)*w(2) + v(2)*wd(2) + vd(3)*w(3) &
&     + v(3)*wd(3)
    d = v(1)*w(1) + v(2)*w(2) + v(3)*w(3)
  END SUBROUTINE DOT_PROD_D
!  Differentiation of dot_prod in reverse (adjoint) mode:
!   gradient     of useful results: d v w
!   with respect to varying inputs: v w
  SUBROUTINE DOT_PROD_B(d, db, v, vb, w, wb)
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) :: v, w
    REAL, DIMENSION(3) :: vb, wb
    REAL :: d
    REAL :: db
    vb(1) = vb(1) + w(1)*db
    wb(1) = wb(1) + v(1)*db
    vb(2) = vb(2) + w(2)*db
    wb(2) = wb(2) + v(2)*db
    vb(3) = vb(3) + w(3)*db
    wb(3) = wb(3) + v(3)*db
  END SUBROUTINE DOT_PROD_B
  SUBROUTINE POINT_TRI(a, b, c, p, dsquared)
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) :: a, b, c, p
    REAL, INTENT(OUT) :: dsquared
    REAL, DIMENSION(3) :: ab, ac, ap, bp, cp, closepoint, diff, &
&   dummydiff
    REAL :: d1, d2, d3, d4, d5, d6
    REAL :: v, vc, vb, va, w, denom
    ab = b - a
    ac = c - a
    ap = p - a
    CALL DOT_PROD(d1, ab, ap)
    CALL DOT_PROD(d2, ac, ap)
    IF (d1 .LE. 0.0 .AND. d2 .LE. 0.0) THEN
! barycentric 1, 0, 0
      closepoint = a
      diff = closepoint - p
      dummydiff = diff
      CALL DOT_PROD(dsquared, diff, dummydiff)
      RETURN
    ELSE
! check if P in vertex region outside B
      bp = p - b
      CALL DOT_PROD(d3, ab, bp)
      CALL DOT_PROD(d4, ac, bp)
      IF (d3 .GE. 0.0 .AND. d4 .LE. d3) THEN
! barycentric 0, 1, 0
        closepoint = b
        diff = closepoint - p
        dummydiff = diff
        CALL DOT_PROD(dsquared, diff, dummydiff)
        RETURN
      ELSE
! check if P in edge region of AB, if so return projection of P onto AB
        vc = d1*d4 - d3*d2
        IF (vc .LE. 0.0 .AND. d1 .GE. 0.0 .AND. d3 .LE. 0.0) THEN
          v = d1/(d1-d3)
! barycentric coordinates (1-v,v,0)
          closepoint = a + v*ab
          diff = closepoint - p
          dummydiff = diff
          CALL DOT_PROD(dsquared, diff, dummydiff)
          RETURN
        ELSE
! Check if P in vertex region C
          cp = p - c
          CALL DOT_PROD(d5, ab, cp)
          CALL DOT_PROD(d6, ac, cp)
          IF (d6 .GE. 0.0 .AND. d5 .LE. d6) THEN
! barycentric coordinates (0,0,1)
            closepoint = c
            diff = closepoint - p
            dummydiff = diff
            CALL DOT_PROD(dsquared, diff, dummydiff)
            RETURN
          ELSE
! check if P in edge region of AC, if so, return proj(P,AC)
            vb = d5*d2 - d1*d6
            IF (vb .LE. 0.0 .AND. d2 .GE. 0.0 .AND. d6 .LE. 0.0) THEN
              w = d2/(d2-d6)
! barycentric (1-w, 0, w)
              closepoint = a + w*ac
              diff = closepoint - p
              dummydiff = diff
              CALL DOT_PROD(dsquared, diff, dummydiff)
              RETURN
            ELSE
! Check if P in edge region of BC, if so, return proj(P,BC)
              va = d3*d6 - d5*d4
              IF (va .LE. 0.0 .AND. d4 - d3 .GE. 0.0 .AND. d5 - d6 .GE. &
&                 0.0) THEN
                w = (d4-d3)/(d4-d3+(d5-d6))
! barycentric (0, 1-w, w)
                closepoint = b + w*(c-b)
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(dsquared, diff, dummydiff)
                RETURN
              ELSE
! P inside face region. Compute Q through barycentric (u, v, w)
                denom = 1.0/(va+vb+vc)
                v = vb*denom
                w = vc*denom
                closepoint = a + ab*v + ac*w
                diff = closepoint - p
                dummydiff = diff
                CALL DOT_PROD(dsquared, diff, dummydiff)
                RETURN
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END SUBROUTINE POINT_TRI
  SUBROUTINE LINE_LINE(p1, q1, p2, q2, dsquared)
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) :: p1, q1, p2, q2
    REAL, INTENT(OUT) :: dsquared
    REAL, DIMENSION(3) :: d1, d2, r, diff, c1, c2
    REAL, PARAMETER :: eps=1e-12
    REAL :: a, b, c, e, f, s, t, denom
    d1 = q1 - p1
    d2 = q2 - p2
    r = p1 - p2
    CALL DOT_PROD(a, d1, d1)
    CALL DOT_PROD(e, d2, d2)
    CALL DOT_PROD(f, d2, r)
    IF (a .LE. eps .AND. e .LE. eps) THEN
! both segments degenrate into points
      diff = q1 - p1
      CALL DOT_PROD(dsquared, diff, diff)
      RETURN
    ELSE
      IF (a .LE. eps) THEN
        s = 0.0
        t = f/e
        CALL CLAMP(t, 0.0, 1.0)
      ELSE
        CALL DOT_PROD(c, d1, r)
        IF (e .LE. eps) THEN
          t = 0.0
          s = -(c/a)
          CALL CLAMP(s, 0.0, 1.0)
        ELSE
! General non-degenerate case
          CALL DOT_PROD(b, d1, d2)
          denom = a*e - b*b
          IF (denom .NE. 0.0) THEN
            s = (b*f-c*e)/denom
            CALL CLAMP(s, 0.0, 1.0)
          ELSE
            s = 0.0
          END IF
          t = (b*s+f)/e
          IF (t .LT. 0.0) THEN
            t = 0.0
            s = -(c/a)
            CALL CLAMP(s, 0.0, 1.0)
          ELSE IF (t .GT. 1.0) THEN
            t = 1.0
            s = (b-c)/a
            CALL CLAMP(s, 0.0, 1.0)
          END IF
        END IF
      END IF
      c1 = p1 + d1*s
      c2 = p2 + d2*t
      diff = c2 - c1
      CALL DOT_PROD(dsquared, diff, diff)
      RETURN
    END IF
  END SUBROUTINE LINE_LINE
  SUBROUTINE DOT_PROD(d, v, w)
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) :: v, w
    REAL, INTENT(OUT) :: d
    d = v(1)*w(1) + v(2)*w(2) + v(3)*w(3)
  END SUBROUTINE DOT_PROD
  SUBROUTINE CLAMP(n, min, max)
    IMPLICIT NONE
    REAL, INTENT(IN) :: min, max
    REAL, INTENT(INOUT) :: n
    IF (n .LT. min) n = min
    IF (n .GT. max) n = max
  END SUBROUTINE CLAMP
END MODULE triangles
